#### 1. 原型
![原型](https://github.com/pangbooo/Typescript/blob/javascript-advanced-shangguigu/imgs/原型.png)

1. 每个函数都有一个 __prototype__ 属性，prototype属性默认指向一个Object空对象（自己定义的属性），叫做原型对象。

2. 原型对象中有一个属性 __constructor__, 它指向函数对象本身。 

3. 当函数以构造函数使用时，创建的对象会有一个隐含属性（```__proto__```）指向原型对象。(所有创建的实例都可以访问)

4. 当访问一个对象的属性，现在自身寻找，找不到再去原型对象里找。原型对象里找不到继续沿着__proto__这条链向上找，如果在Object原型中没找到，则返回undefined。
```javascript
console.log(Object.prototype.__proto__); //null
```

5. 获取对象是否有某个属性的方法
* ```in```   - 检查对象本身和原型上是否存在某个方法
* hasWonProperty - 只检查属性本身是否存在某个方法

```javascript
function Myclass(){}
Myclass.prototype.name = '123';

var mc = new Myclass();
console.log('name' in mc); //true
console.log(mc.hasOwnProperty('name')) // false

```

#### 2.原型深入
1. 函数的显示原型指向的对象是默认的空Object实例对象（Object除外）
```javascript
function Fn(){}

console.log(Fn.prototype instanceOf Object); // true
console.log(Object.prototype instanceOf Object); // false
console.log(Function.prototype instanceOf Object); // true
```

2. 所有函数都是Function的实例（包含Function）
```javascript
Function = new Function();
console.log(Function.__proto__ === Function.prototype); //true
```

3. Object的原型对象是原型链的尽头

#### 3. instanceOf
```A instanceOf B```, A：实例对象，B：构造函数。</br >
如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false。
```javascript
function Fn() {}
var fn = new Fn();

console.log(fn instanceOf Fn); //true
console.log(fn instanceOf Object); //true
```

#### 4. 测试题
```javascript
function A(){}
A.prototype.n = 1;

var b = new A();

A.prototype = {
    n: 2,
    m: 3,
}

var c = new A();
console.log(b.n, b.m, c.n, c.m); // 1 undefined 2 3
```

```javascript
function F() {}
Object.prototype.a = function() {
    console.log('a');
}

Function.prototype.b = function() {
    console.log('b');
}

var f = new F();

f.a(); // a 
//（f -> f构造函数本身 -> F.prototype -> F.prototype.__proto -> Object.prototype）
f.b(); // f.b is not a function
F.a(); // a, (F -> F构造函数本身（Function）-> Function.prototype -> Function.prototype.__proto__ -> Object.prototype)
F.b(); // b
```