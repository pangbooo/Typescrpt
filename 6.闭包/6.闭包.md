```javascript
function fn1() {
    var a = 1;
    var b = 2;
    function fn2(){ // 调用fn1，然后定义fn2的时候，闭包产生
        console.log(a)
    }
    // return fn2
}

fn1();
```
* 可以在浏览器断点查看闭包，老版本Chrome在没有line8也可以查看，新版本Chrome需要添加line8才能查看到闭包对象```{a:1}```

### 1. 如何产生闭包
当一个嵌套的内部子函数引用了外部父函数的变量（函数）时，就产生了闭包

### 2. 闭包是什么 ？
* 理解一：闭包是嵌套的内部函数
* 理解二：包含被引用变量（函数的对象）
* 注意⚠️：闭包存在于嵌套的内部函数中

### 3. 产生闭包的条件
* 函数嵌套
* 内部函数引用了外部函数的变量

### 4. 常见的闭包
1. 将函数作为另一个函数的返回值
```javascript
function fn1(){
    var a = 1;
    function fn2(){
        a++;
        console.log(a);
    }
    return fn2;
}
var f = fn1(); // ⚠️外部函数执行的时候产生了一个闭包
f(); // 2 (内部函数第一个执行)
f(); // 3 (内部函数第二次执行，此时也是同一个闭包)

fn1(); // ⚠️ 外面函数再次调用才会产生一个新的闭包
```

2. 将函数作为实参，传递给另一个函数
```javascript
function showDelayMsg(msg, time) {
    setTimeout(function(){
        console.log(msg)
    }, time)
}

showDelayMsg('123', 100)
```

### 5. 闭包的作用
1. 使用函数内部的变量在函数执行完之后， 仍然存在于内存中。（延长了局部变量的生命周期）
2. 让函数外部可以操作函数内部的数据。
3. 问题
 * 函数执行后，函数内部声明的变量是否还存在 ？ 
    * 一般情况下不存在，存在于闭包中的变量可能存在。
 * 在函数外部能直接访问函数内部的变量吗？
    * 不能直接访问。可以通过闭包操作内部变量。

### 6. 闭包的生命周期
1. 产生： 在内部函数定义阶段就已经产生
2. 死亡：在内部函数成为垃圾对象时
```javascript
function fn1() {
    // 此时函数闭包已经产生了（函数提升，内部函数对象已经创建）
    var a = 1;
    function fn2(){
        console.log(a)
    }
    return fn2;
}
var f = fn1();
f = null; // fn2成为垃圾对象，闭包消失。
```

### 7. 内存溢出、内存泄露
* 内存溢出：当程序运行需要的空间超出剩余空间，就抛出内存溢出的错误
* 内存泄漏：占用的内存没有及时释放
    * 内存泄漏多了就容易导致内存溢出
    * 常见的内存泄漏：1）意外的全局变量；2）没有及时清理定时器或者回掉函数；3）闭包

### 8. 面试题
```javascript
function fun(n, o) {
    console.log(o);
    return {
        fun: function(m){
            return fun(m, n)
        }
    }
}

var a = fun(0)
a.fun(1);
a.fun(2);
a.fun(3); // undefined, 0, 0，0

var b = fun(0).fun(1).fun(2).fun(3); // undefined, 0，1，2，3

var c = fun(0).fun(1); // undefined、0
c.fun(2); // 1
c.fun(3); // 1
```
