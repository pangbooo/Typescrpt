## 面向对象
一切以操作对象完成。

## 类

### 1. 类的创建

1 ）创建一个类

```javascript
// index.ts

class Person {
  //定义实例属性
  name = "pangbo";
  age = 18;
  readonly sex = 'female';

  //定义静态属性（类属性）
  static id = '123';

  //定义方法
  sayHello() {
    console.log('hello!');
  }

  //定义静态方法 (类方法)
  static sayBye() {
    console.log('bye!');
  }
}

const person1 = new Person();
console.log(person1.name);
console.log(person1.age);

console.log(Person.id);
```

* 实例属性 - 通过实例对象访问的属性
* 静态属性 - 直接通过class访问

2）执行编译， 生成index.js

```javascript
tsc -w // 开启监视模式
```

### 2. 构造函数和this

```javascript
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  saySomenthing() {
    console.log(this.name);
  }
}

const person1 = new Person('p', 18);
const person2 = new Person('pp', 20);
```

* constructor函数 - 在对象创建时，被调用
* this - 当前被创建的那个对象

### 3.继承

```javascript
class Animal {
  name: string;
  age: number;

  constructor(name: string, age: number) {
      this.name = name;
      this.age = age;
  }

  sayHello() {
      console.log('animal is barking');
  }
}

class Dog extends Animal {
  run() {
      console.log('dog is running');
  }

  //方法的重写
  sayHello() {
      console.log('wangwangwang');
  }
}

class Cat extends Animal {}

const dog = new Dog('p', 18);
dog.run();
dog.sayHello();

const cat = new Cat('pp', 2);
cat.sayHello();
```

* 使用extends 实现继承
* 子类继承了父类所有的实例属性和方法
* 子类可以重写父类的方法，即调用方法会调用到子类的方法

### 4. super

```javascript
class Animal {
  name: string;

  constructor(name: string) {
      this.name = name;
  }

  sayHello() {
      console.log('animal is barking');
  }
}

class Cat extends Animal {
  age: number
  constructor(name: string, age: number){
      // super() 调用父类的构造函数方法。
      super(name);
      this.age = age;
  }
}
const cat = new Cat('pp', 12);
```



* 如果在子类中需要添加构造函数，则必须在```constructor```中调用父类的构造函数使用```super()``` 

### 5. 抽象类 abstract

* 抽象类不能用来创建实例，是专门用来被继承的类。
* 只有在抽象类里面可以添加抽象方法，抽象方法不需要方法体
* 子类必须去实现抽象父类中的抽象方法

```javascript
abstract class Animal {
  name: string;
  constructor(name: string) {
    this.name = name;
  }

  // 抽象方法
  abstract sayHello(): void;
}

class Cat extends Animal {
  sayHello() {
    console.log('cat is barking');
  }
}
```

### 6. 接口 interface

* 接口用来限制类的结构

* 接口可以用来定义对象的结构

* 类使用```implements```去实现接口```interface``` 

  ```javascript
  type myType = {
    name: string,
    age: number
  }
  
  interface MyInterface{
    name: string,
    age: number,
  
    sayHello(): void
  }
  
  const a: myType = {
     name: 'a',
     age: 12
  }
  
  class Animal implements MyInterface {
    name: string;
    age: number;
    constructor(name: string, age: number) {
      this.name = name;
      this.age = age;
    }
  
    sayHello(): void {
      console.log('hello');
  	}
  }
  ```

  
