### 1. 基本构造
```javascript
class Person {}

class Student extends Person{}
// ===> Student 等价于

class Student extends Person{
    constructor(...argus) {
        super(argus)
    }
}
// -----------instanceOf的表现与ES5相同-----------------
let s = new Student();
s instanceOf Student; // true
s instanceOf Person; // true
```
* 继承时，子类 ```Student``` 内部如果显示的定义```constructor```, 那么也必须添加```super()```方法，去调用父类的构造函数。

### 2. 与ES5的不同
1. ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。
2. ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。

### 3. Object.getPrototypeOf()
可以用来从子类上获取父类，因此可以用来判断一个类是否继承了另一个类。
```javascript
class Person {}
class Student extends Person{}

Object.getPrototypeOf(Student) === Person; // true
```

### 4. super
1. ```super```当作函数使用；只可以在```constructor```中使用，否则报错
2. ```super```当作对象使用；在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
```javascript
class Person {
    constructor(){
        this.x = 1;
    }

    print() {
        console.log(this.x);
    }
}

class Student extends Person {
    constructor(){
        super();
        this.x = 2;
    }

    m() {
        super.print();
    }
}

let b = new B();
b.m(); // 2
```

* super 赋值的时候 等同于this。
```javascript
class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 
  }
}

let b = new B();
```