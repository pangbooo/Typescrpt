### 1. 基本构造
* ES5
```javascript
function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ')';
}

let p = new Point(1, 2);
```

* ES6
```javascript
class Point{
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
}

let p = new Point(1, 2);
Point.prototype.constructor === Point; // true
```

### 2. constructor
* ```constructor()``` 是类的默认方法，通过new生成实例的时候，会被自动调用。
```javascript
class Person {

}
// => 等价于
class Person {
    constructor() {}
}
```
* class构造方法必须通过new去创建实例，否则会报错。这点和ES5不同。

### 3. 注意点
1. class不存在变量提升
```javascript
let f = new Foo(); // ReferenceError
class Foo{}
```

2. name 属性
```javascript
class Foo {}
Foo.name // Foo
```

3. this 的指向
类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。
```javascript
class Logger {
  printName(name = 'there') {
    this.print(`Hello ${name}`);
  }

  print(text) {
    console.log(text);
  }
}

const logger = new Logger();
const { printName } = logger;
printName(); // TypeError: Cannot read property 'print' of undefined
```

* 1. bind绑定this实例对象
```javascript
class Logger {
    constructor() {
        this.printName = this.printName.bind(this);
    }
}
```

* 2. 箭头函数
```javascript
class Logger {
  constructor() {
      this.getThis = () => this;
  }
}

let l = new Logger();
l.getThis() === l; // true
```




### 4. 静态方法
__类相当于实例的原型__，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上```static```关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
> ⚠️ 静态方法内部的this指向class本身
```javascript
class Person {
    static getName() {
        this.sayName(); // this 指向class Person
    }

    static sayName() {
        console.log('static sayName')
    }

    sayName() {
        console.log('sayName')
    }
}

Person.getName(); // static sayName
```
* 静态方法可以被继承
```javascript
class Person {
    static getName() {
        console.log('getName')
    }
}

class Student extends Person {}

Student.getName(); // 'getName'
```

```javascript
class Person {
    static getName() {
        return 'getName'
    }
}

class Student extends Person {
    static getName() {
        return 'Child Class ' + super.getName();
    }
}

Student.getName(); // Child Class getName
```

### 5. 实例属性的新写法
```javascript
class Person {
    constructor() {
        this._name = 'a';
    }
}

class Person {
    _name = 'a';
}
```

### 6. new.target
ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。
```javascript
class Person {
    constructor() {
        console.log(new.target === Person);
    }
}

class Student extends Person {
    constructor() {
        super();
    }
}

let p = new Person(); // true
let s = new Student(); // false
```