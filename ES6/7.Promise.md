## 1. Promise 的状态
实例对象中的一个属性```PromiceState```。
### 三种状态
* pending （未定的初始状态）
* resolved / fullfilled
* rejected

### 两种变化过程
promise状态变化只会发一次，且只有这两种，状态发生改变之后之后就不会改变了。
* pending -> resolved
* pending -> rejected

## 2.Promise 对象的值
实例对象总的另一个属性```PromiseRedult```。保存着对象成功/失败的结果<br/>
只有```resolve```和```reject```可以修改这个值

## 3.API
### 3.1 Promise 构造函数
```javascript
const p = new Promise((resolve reject) => {
    console.log('promise 开始执行')
    //成功
    if (success) {
        resolve();
    } else {
        // 失败
        reject();
    }
});
console.log('222');
//promise 开始执行
// '222'
```
> 注意⚠️：内部函数会在promise内部立即同步调用，异步操作在执行器中执行

### 3.2 Promise原型的方法
Promise 实例具有这三个方法，也就是说，这三个方法是定义在原型对象。
* Promise.prototype.then()
* Promise.prototype.catch()
* Promise.protype.finally()


### 3.3 Promise函数方法
#### Promise.resolve()
* 如果传入的参数为 __非__ Promise类型的对象，则返回的结果为成功的Promise对象
* 如果传入的参数为 Promise类型的对象，则返回的结果由传入的参数决定
```javascript
let p1 = Promise.resolve(123); // PromiceState: fullfilled
let p2 = Promise.resolve(new Promise((resolve, reject) => {
    reject('error')
})); // PromiseState: 'rejected', PromiseResult: 'error'
```

#### Promise.reject()
返回一个失败的promise对象

#### Promise.all(promises)
* 参数promises是包含n个promise的数组。
* 返回一个新的promise，只有所有promise都成功才返回成功，否则返回失败
    * 成功的返回成功的结果数组
    * 失败则只返回第一个失败的结果
```javascript
let p1 = new Promise((resolve, reject) => {
    resolve('ok');
});
let p2 = Promise.resolve('Success');
let p3 = Promise.resolve('Success');
const result = Promise.all([p1, p2, p3]);
console.log(result);
/**
 * Prototype: Promise
 * PromiseState: 'fullfilled'
 * PromiseResult: ['ok', 'Success', 'Success']
 * **/
```

```javascript
let p1 = new Promise((resolve, reject) => {
    resolve('ok');
});
let p2 = Promise.resolve('Success');
let p3 = Promise.reject('Error'); // p2是失败的promise
const result = Promise.all([p1, p2, p3]);
console.log(result);
/**
 * Prototype: Promise
 * PromiseState: 'rejected'
 * PromiseResult: 'Error'
 * **/
```

#### Promise.race(promises)
* 参数promises是包含n个promise的数组。
* 返回一个新的promise对象，结果为第一个完成的promise的结果

## 4. 关键问题
### 4.1 可以修改promise对象状态的方法总结
* resolve()
* reject()
* throw
```javascript
let p = new Promise((resolve, reject) => {
    throw 'Error'
});
console.log(p);
/**
 * Prototype: Promise
 * PromiseState: 'rejected'
 * PromiseResult: 'Error'
 * **/
```

### 4.2 promise多个then方法，会被调用吗?
会被调用。
```javascript
let p = Promise.resolve('ok');
p.then( res => console.log(res + '0'));
p.then( res => console.log(res + '1'));
```

### 4.3 then 方法返回的结果由什么决定
then回调方法返回一个promise对象，结果值```PromiseResult```由then内部返回结果决定
* 1. then内部抛出错误
```javascript
let p = new Promise((resolve, reject) => {
    resolve('ok')
});

const result = p.then((res) => {
    throw 'Error'
});

console.log(result);

/**
 * Prototype: Promise
 * PromiseState: 'rejected'
 * PromiseResult: 'Error'
 * **/
```

* 2. then内部返回一个非promise对象
```javascript
let p = new Promise((resolve, reject) => {
    resolve('ok')
});

const result = p.then((res) => {
    return 123
});

console.log(result);

/**
 * Prototype: Promise
 * PromiseState: 'fulfilled'
 * PromiseResult: 123
 * **/
```

* 3. then内部返回一个promise对象
```javascript
let p = new Promise((resolve, reject) => {
    resolve('ok')
});

const result = p.then((res) => {
    return new Promise((resolve, reject) => {
        resolve('ok')
    })
});

console.log(result);

/**
 * Prototype: Promise
 * PromiseState: 'fulfilled'
 * PromiseResult: 'okkkk'
 * **/
```

### 4.4 如何中断promise链
使promise对象状态变为pending
```javascript
let p = new Promise((resolve, reject) => {
    resolve('ok')
});

p.then((res) => {
    console.log(res);
    return new Promise(() => {}) // 此处返回了一个pending状态的promise对象，链中断了。
}).then((res) => {
    console.log(res);
});

// 'ok'
```