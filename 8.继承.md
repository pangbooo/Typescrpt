### 1. 原型链继承
```javascript
function Super() {
    this.superProps = 'Super Props';
}
Super.prototype.showSuperProps = function() {
    console.log(this.superProps)
}

function Sub() {
    this.subProps = 'Sub Props';
}
//实现继承 -> 子类的原型对象指向父类的实例对象（同时也父类的原型对象）
Sub.prototype = new Super();

// 让子类的constructor构造函数指向Sub本身的构造函数
Sub.prototype.construtor = Sub; // 不指定之前指向了Super

Sub.prototype.showSubProps = function() {
    console.log(this.subProps)
}

const s2 = new Sub();
s2.showSubProps();
s2.showSuperProps();
```

### 2. 借用构造函数继承（假的）
在构造函数调用```call()```方法，借用父类的语句。
```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}
function Student(name, age, price) {
    Person.call(this, name, age, price)
}

var s = new Student('a', 12, 1000);
console.log(s.name, s.age, s.price) // 'a', 12, 1000
```

### 3. 组合继承 （原型链 + 借用构造函数）
```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.setName = function(name) {
    this.name = name;
}

function Student(name, age, price) {
    Person.call(this, name, age, price)
}
Student.prototype = new Person();
Student.prototype.construtor = Student;
Student.prototype.setPrice = function(price) {
    this.price = price;
}

var s = new Student('a', 20, 1000);
s.setName('b');
s.setPrice(2000);
console.log(s.name, s.age, s.price) //"b", 20, 2000
```